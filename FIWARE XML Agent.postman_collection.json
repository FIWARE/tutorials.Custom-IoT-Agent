{
	"info": {
		"_postman_id": "a25317b1-5952-4a35-9730-21c65a6dcc52",
		"name": "FIWARE XML Agent",
		"description": "[![FIWARE IoT Agents](https://nexus.lab.fiware.org/repository/raw/public/badges/chapters/iot-agents.svg)](https://github.com/FIWARE/catalogue/blob/master/iot-agents/README.md)\n[![NGSI v2](https://img.shields.io/badge/NGSI-v2-5dc0cf.svg)](https://fiware-ges.github.io/orion/api/v2/stable/) \n\nThis tutorial a wires up the dummy IoT devices which are responding using a custom [XML](https://www.w3.org/TR/xml11/)\nmessage format. A **custom IoT Agent** is created based on the IoT Agent Node.js\n[library](https://iotagent-node-lib.readthedocs.io/en/latest/) and the framework found in the\n[IoT Agent for Ultralight](https://fiware-iotagent-ul.readthedocs.io/en/latest/usermanual/index.html#user-programmers-manual)\ndevices so that measurements can be read and commands can be sent using\n[NGSI-v2](https://fiware.github.io/specifications/OpenAPI/ngsiv2) requests sent to the\n[Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/).\n\nThe tutorial uses [cUrl](https://ec.haxx.se/) commands throughout, but is also available as\n[Postman documentation](https://fiware.github.io/tutorials.Custom-IoT-Agent/)\n\nThe `docker-compose` files for this tutorial can be found on GitHub: \n\n![GitHub](https://fiware.github.io/tutorials.Custom-IoT-Agent/icon/GitHub-Mark-32px.png) [FIWARE 205: Creating a Custom IoT Agent](https://github.com/Fiware/tutorials.Custom-IoT-Agent)\n\n# Passing custom message formats\n\nAs defined previously, an IoT Agent is a component that lets a group of devices send their data to and be managed from a\nContext Broker using their own native protocols. Every IoT Agent is defined for a single payload format, although they\nmay be able to use multiple disparate transports for that payload.\n\nIoT Agents for many standard payloads exist, however it is possible to envisage that additional payloads may be needed\nas many potential sources of context data have already their own well-defined de-facto or de-jure standards for passing\ndata around systems. As an example the **ISOXML** standard\n[iso:11783](https://www.iso.org/obp/ui/#iso:std:iso:11783:-10:ed-2:v1:en) is frequently used with Agricultural\nMachinery.\n\nThe process for creating your own IoT Agent is relatively simple. It is best achieved through selecting an IoT Agent\nwhich uses the required data transport and rewriting/amending the payload processing code to handle the payloads in\nquestion.\n\nFor the purpose of this tutorial we will amend code from the existing Ultralight IoT Agent to process a similar custom\nXML format. A direct comparison of the two IoT Agents can be seen below:\n\n| IoT Agent for Ultralight                                            | IoT Agent for JSON                                                                    | Protocol's Area of Concern |\n| ------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | -------------------------- |\n| Sample Measure `c\\|1`                                               | Sample Measure `<measure device=\"lamp002\" key=\"xxx\">`<br/>&nbsp;`<c value=\"1\"/>`<br/> |\n| `</measure>`                                                        | Message Payload                                                                       |\n| Sample Command `Robot1@turn\\|left=30`                               | Sample Command `<turn device=\"Robot1\">`<br/>&nbsp;`<left>30</left>`<br/>`</turn>`     | Message Payload            |\n| Content Type is `text/plain`                                        | Content Type is `application/xml`                                                     | Message Payload            |\n| Offers 3 transports - HTTP, MQTT and AMPQ                           | Offers 3 transports - HTTP, MQTT and AMPQ                                             | Transport Mechanism        |\n| HTTP listens for measures on `iot/d` by default                     | HTTP listens for measures on `iot/xml` by default                                     | Transport Mechanism        |\n| HTTP devices are identified by parameters `?i=XXX&k=YYY`            | HTTP devices are identified by payload `<measure device=\"XXX\" key=\"YYY\">`             | Device Identification      |\n| HTTP commands posted to a well-known URL - response is in the reply | HTTP commands posted to a well-known URL - response is in the reply                   | Communications Handshake   |\n| MQTT devices are identified by the path of the topic `/XXX/YYY`     | MQTT devices are identified by the path of the topic `/XXX/YYY`                       | Device Identification      |\n| MQTT commands posted to the `cmd` topic                             | MQTT commands posted to the `cmd` topic                                               | Communications Handshake   |\n| MQTT command responses posted to the `cmdexe` topic                 | MQTT commands posted to the `cmdexe` topic                                            | Communications Handshake   |\n\nAs can be seen, the supported communications transports (HTTP, MQTT, AMPQ) remain the same, it is processing of the\ncustom payload which will need to be adapted to ensure that the XML devices can communicate with the IoT Agent.\n\nIt should be noted that, depending on your use case, it also may be necessary to create an additional middleware for\ncommunications purposes. In this example the _devices_ are capable of sending measures and listening and responding to\ncommands directly on two separate comms channels. A different paradigm is used within the\n[LoRaWAN](https://fiware-lorawan.readthedocs.io) and [OPC-UA](https://iotagent-opcua.readthedocs.io) IoT Agents where an\nHTTP middleware responds to the IoT Agent, and it is then responsible for converting the communications to the\nlower-level CoAP transport used by the devices.\n\n## The teaching goal of this tutorial\n\nThe aim of this tutorial is to improve developer understanding of how to create their own custom IoT Agents, a series of\nsimple modificiations has been made to the code of the Ultralight IoT Agent demonstrating how to make changes. The\ntutorial consists of a walk-through of the relevant code and a series of HTTP requests to connect the new IoT Agent. The\ncode can be found within the current\n[GitHub Repository](https://github.com/FIWARE/tutorials.Custom-IoT-Agent/tree/master/iot-agent)\n\n## Reusing Common Functionality\n\nThe benefit of modifying an existing IoT Agent is that the developer will be able to reuse the common functionality\nfound across all IoT Agents. This includes functions such as:\n\n-   Offering a standard location to listen to device updates\n-   Offering a standard location to listen to context data updates\n-   Holding a list of devices and mapping context data attributes to device syntax\n-   Security Authorization\n\nThis base functionality has been abstracted out into a common\n[IoT Agent framework library](https://iotagent-node-lib.readthedocs.io/)\n\n#### Device Monitor\n\nFor the purpose of this tutorial, a series of dummy IoT devices have been created, which will be attached to the context\nbroker. Details of the architecture and protocol used can be found in the\n[IoT Sensors tutorial](https://github.com/FIWARE/tutorials.IoT-Sensors) The state of each device can be seen on the JSON\ndevice monitor web page found at: `http://localhost:3000/device/monitor`\n\n![FIWARE Monitor](https://fiware.github.io/tutorials.IoT-Agent-JSON/img/device-monitor.png)\n\n# Architecture\n\nThis application builds on the components created in\n[previous tutorials](https://github.com/FIWARE/tutorials.Subscriptions/). It will make use of one FIWARE component - the\n[Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) plus a **Custom IoT Agent for XML**. Usage of the\nOrion Context Broker is sufficient for an application to qualify as _“Powered by FIWARE”_. Both the Orion Context Broker\nand the IoT Agent and rely on open source [MongoDB](https://www.mongodb.com/) technology to keep persistence of the\ninformation they hold. We will also be using the dummy IoT devices created in the\n[previous tutorial](https://github.com/FIWARE/tutorials.IoT-Sensors/), however they have been already been adapted to\nrespond to the custom XML messaging format.\n\nTherefore the overall architecture will consist of the following elements:\n\n-   The FIWARE [Orion Context Broker](https://fiware-orion.readthedocs.io/en/latest/) which will receive requests using\n    [NGSI-v2](https://fiware.github.io/specifications/OpenAPI/ngsiv2)\n-   The **Custom IoT Agent for XML** which will receive southbound requests using\n    [NGSI-v2](https://fiware.github.io/specifications/OpenAPI/ngsiv2) and convert them to XML commands for the devices\n-   The underlying [MongoDB](https://www.mongodb.com/) database :\n    -   Used by the **Orion Context Broker** to hold context data information such as data entities, subscriptions and\n        registrations\n    -   Used by the **IoT Agent** to hold device information such as device URLs and Keys\n-   A webserver acting as set of [dummy IoT devices](https://github.com/FIWARE/tutorials.IoT-Sensors) using the custom\n    XML messaging protocol running over HTTP.\n\nSince all interactions between the elements are initiated by HTTP requests, the entities can be containerized and run\nfrom exposed ports.\n\n![](https://fiware.github.io/tutorials.IoT-Agent-JSON/img/architecture.png)\n\nThe necessary configuration information for wiring up the IoT devices and the IoT Agent can be seen in the services\nsection of the associated `docker-compose.yml` file:\n\n## Dummy IoT Devices Configuration\n\n```yaml\ntutorial:\n    image: quay.io/fiware/tutorials.context-provider\n    hostname: iot-sensors\n    container_name: fiware-tutorial\n    networks:\n        - default\n    expose:\n        - \"3000\"\n        - \"3001\"\n    ports:\n        - \"3000:3000\"\n        - \"3001:3001\"\n    environment:\n        - \"DEBUG=tutorial:*\"\n        - \"PORT=3000\"\n        - \"IOTA_HTTP_HOST=iot-agent\"\n        - \"IOTA_HTTP_PORT=7896\"\n        - \"DUMMY_DEVICES_PORT=3001\"\n        - \"DUMMY_DEVICES_API_KEY=4jggokgpepnvsb2uv4s40d59ov\"\n        - \"DUMMY_DEVICES_TRANSPORT=HTTP\"\n        - \"DUMMY_DEVICES_PAYLOAD=XML\"\n```\n\nThe `tutorial` container is listening on two ports:\n\n-   Port `3000` is exposed so we can see the web page displaying the Dummy IoT devices.\n-   Port `3001` is exposed purely for tutorial access - so that cUrl or Postman can make JSON commands without being\n    part of the same network.\n\nThe `tutorial` container is driven by environment variables as shown:\n\n| Key                     | Value                        | Description                                                                                                                        |\n| ----------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| DEBUG                   | `tutorial:*`                 | Debug flag used for logging                                                                                                        |\n| WEB_APP_PORT            | `3000`                       | Port used by web-app which displays the dummy device data                                                                          |\n| IOTA_HTTP_HOST          | `iot-agent`                  | The hostname of the IoT Agent for JSON - see below                                                                                 |\n| IOTA_HTTP_PORT          | `7896`                       | The port that the IoT Agent for JSON will be listening on. `7896` is a common default for JSON over HTTP                           |\n| DUMMY_DEVICES_PORT      | `3001`                       | Port used by the dummy IoT devices to receive commands                                                                             |\n| DUMMY_DEVICES_API_KEY   | `4jggokgpepnvsb2uv4s40d59ov` | Random security key used for IoT interactions - used to ensure the integrity of interactions between the devices and the IoT Agent |\n| DUMMY_DEVICES_TRANSPORT | `HTTP`                       | The transport protocol used by the dummy IoT devices                                                                               |\n| DUMMY_DEVICES_PAYLOAD   | `XML`                        | The message payload protocol by the dummy IoT devices                                                                              |\n\nThe other `tutorial` container configuration values described in the YAML file are not used in this tutorial.\n\n## Custom XML IoT Agent configuration\n\nThe code for the custom XML IoT Agent can be found within the\n[GitHub Repository](https://github.com/FIWARE/tutorials.Custom-IoT-Agent/tree/master/iot-agent) associated to this\ntutorial. It is a copy of the 1.12.0 version of the IoT Agent for Ultralight, lightly modified as described below. The\nassociated [Dockerfile](https://github.com/FIWARE/tutorials.Custom-IoT-Agent/blob/master/iot-agent/Dockerfile) merely\ncopies the code into an appropiate location within a Docker container running Node.js. This allows the component to be\ninstansiated using a `docker-compose.yaml` file. The necessary configuration can be seen below:\n\n```yaml\niot-agent:\n    image: quay.io/fiware/iotagent-xml\n    build:\n        context: iot-agent\n        dockerfile: Dockerfile\n    hostname: iot-agent\n    container_name: fiware-iot-agent\n    depends_on:\n        - mongo-db\n    networks:\n        - default\n    expose:\n        - \"4041\"\n        - \"7896\"\n    ports:\n        - \"4041:4041\"\n        - \"7896:7896\"\n    environment:\n        - IOTA_CB_HOST=orion\n        - IOTA_CB_PORT=1026\n        - IOTA_NORTH_PORT=4041\n        - IOTA_REGISTRY_TYPE=mongodb\n        - IOTA_LOG_LEVEL=DEBUG\n        - IOTA_TIMESTAMP=true\n        - IOTA_CB_NGSI_VERSION=v2\n        - IOTA_AUTOCAST=true\n        - IOTA_MONGO_HOST=mongo-db\n        - IOTA_MONGO_PORT=27017\n        - IOTA_MONGO_DB=iotagentjson\n        - IOTA_HTTP_PORT=7896\n        - IOTA_PROVIDER_URL=http://iot-agent:4041\n        - IOTA_DEFAULT_RESOURCE=/iot/xml\n```\n\nThe `iot-agent` container relies on the precence of the Orion Context Broker and uses a MongoDB database to hold device\ninformation such as device URLs and Keys. The container is listening on two ports:\n\n-   Port `7896` is exposed to receive JSON measurements over HTTP from the Dummy IoT devices\n-   Port `4041` is exposed purely for tutorial access - so that cUrl or Postman can make provisioning commands without\n    being part of the same network.\n\nThe `iot-agent` container is driven by environment variables as shown:\n\n| Key                   | Value                   | Description                                                                                                                                           |\n| --------------------- | ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\n| IOTA_CB_HOST          | `orion`                 | Hostname of the context broker to update context                                                                                                      |\n| IOTA_CB_PORT          | `1026`                  | Port that context broker listens on to update context                                                                                                 |\n| IOTA_NORTH_PORT       | `4041`                  | Port used for Configuring the IoT Agent and receiving context updates from the context broker                                                         |\n| IOTA_REGISTRY_TYPE    | `mongodb`               | Whether to hold IoT device info in memory or in a database                                                                                            |\n| IOTA_LOG_LEVEL        | `DEBUG`                 | The log level of the IoT Agent                                                                                                                        |\n| IOTA_TIMESTAMP        | `true`                  | Whether to supply timestamp information with each measurement received from attached devices                                                          |\n| IOTA_CB_NGSI_VERSION  | `v2`                    | Whether to supply use NGSI v2 when sending updates for active attributes                                                                              |\n| IOTA_AUTOCAST         | `true`                  | Ensure JSON number values are read as numbers not strings                                                                                             |\n| IOTA_MONGO_HOST       | `context-db`            | The hostname of mongoDB - used for holding device information                                                                                         |\n| IOTA_MONGO_PORT       | `27017`                 | The port mongoDB is listening on                                                                                                                      |\n| IOTA_MONGO_DB         | `iotagentjson`          | The name of the database used in mongoDB                                                                                                              |\n| IOTA_HTTP_PORT        | `7896`                  | The port where the IoT Agent listens for IoT device traffic over HTTP                                                                                 |\n| IOTA_PROVIDER_URL     | `http://iot-agent:4041` | URL passed to the Context Broker when commands are registered, used as a forwarding URL location when the Context Broker issues a command to a device |\n| IOTA_DEFAULT_RESOURCE | `/iot/xml`              | The default path the IoT Agent uses listenening for custom XML measures.                                                                              |",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Creating a Custom IoT Agent",
			"item": [
				{
					"name": "IoT Agent - Obtain Version Information",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "http://{{iot-agent}}/iot/about",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"about"
							]
						},
						"description": "Once the IoT Agent is running, You can check the status by making an HTTP request to the exposed port. \nIf the response is blank, this is usually because the MongoDB database holding the context information is not running or not connected.\n\nThis is standard functionality coming directly from the IoT Agent Node.js library and does not involve an code changes."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Create a Service Group",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"services\": [\n   {\n     \"apikey\":      \"4jggokgpepnvsb2uv4s40d59ov\",\n     \"cbroker\":     \"http://orion:1026\",\n     \"entity_type\": \"Thing\",\n     \"resource\":    \"/iot/xml\"\n   }\n ]\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/services",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"services"
							]
						},
						"description": "In the example the IoT Agent is informed that the `/iot/xml` endpoint will be used and that devices will authenticate\nthemselves by including the token `4jggokgpepnvsb2uv4s40d59ov`. For the custom XML IoT Agent this means devices will be\nsending POST requests to:\n\n```\nhttp://iot-agent:7896/iot/xml\n```\n\nWhere the `<measure>` holds the relevant device ID and API key.\n\n```\n<measure device=\"motion001\" key=\"4jggokgpepnvsb2uv4s40d59ov\">\n    <c value=\"3\"/>\n</measure>\n```\n\nThis syntax differs from the Ultralight IoT Agent where the device ID and API key are sent as URL parameters.\n\nThe relevant changes can be found in the `HTTPBindings.js` file where an XML parser is instanciated.\n\n```javascript\nconst xmlBodyParser = require(\"express-xml-bodyparser\");\n```\n\n```javascript\nhttpBindingServer.router.post(\n    config.getConfig().iota.defaultResource || constants.HTTP_MEASURE_PATH,\n    ...xmlBodyParser({ trim: false, explicitArray: false }),\n    checkMandatoryParams(false),\n    ...etc\n);\n```\n\nThis means that attributes from the XML request can be accessed using the square-bracket syntax. Since both `apiKey` and\n`deviceId` are required parameters, they can be found within the received `<measure>`.\n\n```javascript\nfunction checkMandatoryParams(queryPayload) {\n    return function(req, res, next) {\n        var notFoundParams = [],\n            error;\n\n        req.apiKey = req.body[\"measure\"][\"$\"][\"key\"];\n        req.deviceId = req.body[\"measure\"][\"$\"][\"device\"];\n\n        if (!req.apiKey) {\n            notFoundParams.push(\"API Key\");\n        }\n\n        if (!req.deviceId) {\n            notFoundParams.push(\"Device Id\");\n        }\n\n        // CHeck if retrievingParam\n        if (queryPayload && !req.query.d && req.query.getCmd !== \"1\") {\n            notFoundParams.push(\"Payload\");\n        }\n\n        if (req.method === \"POST\" && !req.is(\"application/xml\")) {\n            error = new errors.UnsupportedType(\"application/xml\");\n        }\n\n        if (notFoundParams.length !== 0) {\n            next(new errors.MandatoryParamsNotFound(notFoundParams));\n        } else {\n            next(error);\n        }\n    };\n}\n```\n\nThis function also checks that the appropriate MIME type has been received and fails fast if the incoming message does\nnot hold sufficient information."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Sensor",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"devices\": [\n   {\n     \"device_id\":   \"motion001\",\n     \"entity_name\": \"urn:ngsd-ld:Motion:001\",\n     \"entity_type\": \"Motion\",\n     \"timezone\":    \"Europe/Berlin\",\n     \"attributes\": [\n       { \"object_id\": \"c\", \"name\":\"count\", \"type\":\"Integer\"}\n      ],\n      \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n      ]\n   }\n ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "As expected the HTTP command to **provision a device** does not change based on the underlying payload or transport\nprotocol since we are using the same HTTP transport as the original Ultralight IoT Agent. `internal_atttributes` can be\nused to supply additional information for the custom IoT Agent if necessary. In the request we are associating the\ndevice `motion001` with the URN `urn:ngsi-ld:Motion:001` and mapping the device reading `c` with the context attribute\n`count` (which is defined as an `Integer`) A `refStore` is defined as a `static_attribute`, placing the device within\n**Store** `urn:ngsi-ld:Store:001`"
					},
					"response": []
				},
				{
					"name": "Dummy Device  - Measurement",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"name": "Content-Type",
								"value": "application/xml",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "<measure device=\"motion001\" key=\"4jggokgpepnvsb2uv4s40d59ov\">\n\t<c value=\"3\"/>\n</measure>"
						},
						"url": {
							"raw": "http://localhost:7896/iot/xml",
							"protocol": "http",
							"host": [
								"localhost"
							],
							"port": "7896",
							"path": [
								"iot",
								"xml"
							]
						},
						"description": "You can simulate a dummy IoT device measurement coming from the **Motion Sensor** device `motion001`, by making the\nfollowing XML request\n\nBoth the payload and the `Content-Type` have been updated. The dummy devices made a similar Ultralight request in the\nprevious tutorials when the door was unlocked, you will have seen the state of each motion sensor changing and a\nNorthbound request will be logged in the device monitor.\n\nNow the IoT Agent is connected, the service group has defined the resource upon which the IoT Agent is listening\n(`iot/xml`) and the API key used to authenticate the request (`4jggokgpepnvsb2uv4s40d59ov`) is found in the body. Since\nboth of these are recognized, the measurement is valid.\n\nThe next step is to parse the payload extract the attributes. This can be found in the amended `parse` method of the\n`xmlparser.js` file\n\n```javascript\nfunction parse(payload) {\n    let result = [];\n    const keys = Object.keys(payload[\"measure\"]);\n    for (let i = 0; i < keys.length; i++) {\n        if (keys[i] !== \"$\") {\n            let obj = {};\n            obj[keys[i]] = payload[\"measure\"][keys[i]][\"$\"].value;\n            result.push(obj);\n        }\n    }\n    return result;\n}\n```\n\n`parse()` returns a JSON array of key-value pairs which can then be mapped from device attribute names (like `c`) to\nentity attribute names (like `count`) - obviously the mapping is based on the values sent in the original provisioning."
					},
					"response": []
				},
				{
					"name": "Context Broker - Read the Motion Sensor",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}/v2/entities/urn:ngsd-ld:Motion:001",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsd-ld:Motion:001"
							]
						},
						"description": "You can see that a measurement has been recorded, by retrieving the entity data from the context broker. Don't forget to\nadd the `fiware-service` and `fiware-service-path` headers.\n\n\nThe response shows that the device with `id=motion001` has been successfully identifed by the IoT Agent and mapped to the\nentity `id=urn:ngsd-ld:Motion:001`. This new entity has been created within the context data. The `c` \nattribute from the dummy device measurement request has been mapped to the more meaningful `count` attribute\nwithin the context. As you will notice, a `TimeInstant` attribute has been added to both the entity and the\nmeta data of the attribute - this represents the last time the entity and attribute have been updated, and is\nautomatically added to each new entity because the `IOTA_TIMESTAMP`  environment variable was set when the\nIoT Agent was started up. The `refStore` attribute comes from the `static_attributes` set when the device was provisioned."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision an Actuator",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"bell001\",\n      \"entity_name\": \"urn:ngsi-ld:Bell:001\",\n      \"entity_type\": \"Bell\",\n      \"transport\": \"HTTP\",\n      \"endpoint\": \"http://iot-sensors:3001/iot/bell001\",\n      \"commands\": [ \n        {\n          \"name\": \"ring\",\n          \"type\": \"command\"\n        }\n       ],\n       \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n    \t]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning an actuator is similar to provisioning a sensor. This time an `endpoint` attribute holds the location where\nthe IoT Agent needs to send the JSON command and the `commands` array includes a list of each command that can be\ninvoked. The example below provisions a bell with the `deviceId=bell001`. The endpoint is\n`http://iot-sensors:3001/iot/bell001` and it can accept the `ring` command. The `transport=HTTP` attribute defines the\ncommunications protocol to be used.\n\nAs is the case with provisioning a measure, this request remains unchanged. Implicitly within the structure of the IoT\nAgent the provisioning of commands fulfills the following implied contract:\n\n1.  The custom IoT Agent is making a registration for an attribute\n2.  The custom IoT Agent each request for updating context (on the `/v2/op/update` endpoint)\n3.  A decision is made how to handle the request - for both the Custom IoT Agent and the Ultralight Agent this follows\n    the paradigm of setting a `<command>State` attribute, amending and forwarding the request on a `/cmd` endpoint to\n    the device (or alternatively to a middleware responsible for the device).\n\nThe first two items - listening to context changes from the context broker follow the well-defined NGSI syntax and\ntherefore are common to all IoT Agents. However the third item - what to do to prepare the message for ongoing\nconsumption will vary according to the protocol which is being abstracted out.\n"
					},
					"response": []
				},
				{
					"name": "IoT Agent - Invoke a Command",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"actionType\": \"update\",\n    \"entities\": [\n        {\n            \"type\": \"Bell\",\n            \"id\": \"urn:ngsi-ld:Bell:001\",\n            \"ring\" : {\n                \"type\": \"command\",\n                \"value\": \"\"\n            }\n        }\n    ]\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}/v2/op/update",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"v2",
								"op",
								"update"
							]
						},
						"description": "Before we wire-up the context broker, we can test that a command can be send to a device by making a REST request\ndirectly to the IoT Agent's North Port using the `/v2/op/update` endpoint. It is this endpoint that will eventually be\ninvoked by the context broker once we have connected it up. To test the configuration you can run the command directly\nas shown\n\nIf you are viewing the device monitor page, you can also see the state of the bell change.\n\n![](https://fiware.github.io/tutorials.IoT-Agent/img/bell-ring.gif)\n\nThe result of the command to ring the bell can be read by querying the entity within the Orion Context Broker.\n\nWithin the custom IoT Agent the `start()` function sets a series of handler functions to fire when a request arrives\nfrom the context broker.\n\n```javascript\niotAgentLib.setProvisioningHandler(deviceProvisioningHandler);\niotAgentLib.setConfigurationHandler(configurationHandler);\niotAgentLib.setCommandHandler(commandHandler);\niotAgentLib.setDataUpdateHandler(updateHandler);\n```\n\nThis is passed to the appropriate transport binding and in this case, the `commandHandler()` method within\n`HTTPBindings.js` is fired. It provides an HTTP error handler, but delegates the actual work of creating and sending the\ncommand to the device to `generateCommandExecution()`.\n\n```javascript\nfunction generateCommandExecution(apiKey, device, attribute) {\n...\n    const options = {\n        url: device.endpoint,\n        method: 'POST',\n        body: xmlParser.createCommandPayload(device, cmdName, cmdAttributes),\n        headers: {\n            'fiware-service': device.service,\n            'fiware-servicepath': device.subservice\n        }\n    };\n... etc\n```\n\nThe payload itself, in other words how a command must be created such that it can be interpreted by the device, is\nunique to our custom XML messaging protocol and is generated in `createCommandPayload()` method in `xmlParser.js`.\n\n```javascript\nfunction createCommandPayload(device, command, attributes) {\n    if (typeof attributes === \"object\") {\n        let payload = \"<\" + command + '  device=\"' + device.id + '\">';\n\n        Object.keys(attributes).forEach(function(key, value) {\n            payload = payload + \"<\" + key + \">\" + value + \"</\" + key + \">\";\n        });\n        payload = payload + \"</\" + command + \">\";\n        return payload;\n    } else {\n        return \"<\" + command + '  device=\"' + device.id + '\"/>';\n    }\n}\n```\n\nThis is an amendment from the Ultralight protocol where the `@` and `|` symbol is generated for Ultralight devices.\n\nHowver creating a payload is only half the job, it must be sent to the device and understood, so communications must be\ncompleted using a well-defined communications handshake. So after generating the payload the `sendXMLCommandHTTP()`\nmethod of `HTTPBindings.js` sends the message and passes the response to the `result()` method in `xmlParser.js` to\ninterprets the command response from the device.\n\n```javascript\nfunction result(payload) {\n    const xmlToJson = require(\"xml-parser\");\n    const data = xmlToJson(payload);\n    const result = {};\n    result.deviceId = data.root.attributes.device;\n    result.command = data.root.attributes.command;\n    result.result = data.root.name;\n\n    return result;\n}\n```\n\nFinally the success or failure of the command is updated into the context broker using common code from the IoT Agent\nnode library.\n\nAs is typical for IoT Agents, creation of payloads and the handshake of communications has been split into two separate\nconcerns for ease of maintenance. Therefore since in our case only the payload has changed, it is only the XML payload\nside of the code that needs modification to fulfil our custom use case.\n"
					},
					"response": []
				},
				{
					"name": "Context Broker - Read the Command Result",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}/v2/entities/urn:ngsi-ld:Bell:001?options=keyValues",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Bell:001"
							],
							"query": [
								{
									"key": "options",
									"value": "keyValues"
								}
							]
						},
						"description": "The result of the command to ring the bell can be read by querying the entity within the Orion Context Broker. \n"
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Smart Door",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"door001\",\n      \"entity_name\": \"urn:ngsi-ld:Door:001\",\n      \"entity_type\": \"Door\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"HTTP\",\n      \"endpoint\": \"http://iot-sensors:3001/iot/door001\",\n      \"commands\": [ \n        {\"name\": \"unlock\",\"type\": \"command\"},\n        {\"name\": \"open\",\"type\": \"command\"},\n        {\"name\": \"close\",\"type\": \"command\"},\n        {\"name\": \"lock\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n       \t{\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"}\n       ],\n       \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n       ]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning  a device which offers both commands and measurements is merely a matter of making an HTTP POST request\nwith both `attributes` and `command` attributes in the body of the request.\n\nThis example provisions a smart door with four commands `lock`, `unlock`, `open` and `close` and maps a single attribute."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Smart Lamp",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"lamp001\",\n      \"entity_name\": \"urn:ngsi-ld:Lamp:001\",\n      \"entity_type\": \"Lamp\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"HTTP\",\n      \"endpoint\": \"http://iot-sensors:3001/iot/lamp001\",\n      \"commands\": [ \n        {\"name\": \"on\",\"type\": \"command\"},\n        {\"name\": \"off\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n       \t{\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"},\n        {\"object_id\": \"l\", \"name\": \"luminosity\", \"type\":\"Integer\"}\n       ],\n       \"static_attributes\": [\n         {\"name\":\"refStore\", \"type\": \"Relationship\",\"value\": \"urn:ngsi-ld:Store:001\"}\n    \t]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning  a device which offers both commands and measurements is merely a matter of making an HTTP POST request\nwith both `attributes` and `command` attributes in the body of the request.\n\nThis example provisions a smart door with two commands `on` and `off` and maps two attributes."
					},
					"response": []
				},
				{
					"name": "IoT Agent - List all Provisioned Devices",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "openiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{iot-agent}}/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "This example lists all provisioned devices by making a GET request to the `/iot/devices` endpoint.\n\nThe response includes all the commands and attributes mappings associated with all provisioned IoT devices."
					},
					"response": []
				}
			],
			"description": "The following section consists of a series of HTTP commands used to provision the IoT Agent and receive measures and\nsend commands. The relevant amended code within the Custom IoT Agent is discussed as each action is processed.\n\nTo follow the tutorial correctly please ensure you have the device monitor page available in your browser and click on\nthe page to enable audio before you enter any cUrl commands. The device monitor displays the current state of an array\nof dummy devices using XML syntax\n\n#### Device Monitor\n\nThe device monitor can be found at: `http://localhost:3000/device/monitor`\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "661d9977-6eda-41bc-ab3a-5ab127cf21a5",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"id": "1c47421c-2f50-4cee-add5-99cb44744a53",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			],
			"protocolProfileBehavior": {}
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "e64b3c59-ab46-46cf-b504-30a027ca2986",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "04676146-332d-41b3-a65e-b9fd5a527aca",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"id": "32c7f743-7de9-49f3-96b4-92d1ff47f847",
			"key": "iot-agent",
			"value": "localhost:4041",
			"type": "string"
		},
		{
			"id": "bee9e9f7-bbe2-48f8-8ba9-352e38765f3f",
			"key": "orion",
			"value": "localhost:1026",
			"type": "string"
		},
		{
			"id": "f4e9ce6f-79a8-4db0-abe0-9af4e6c8eed0",
			"key": "ultralight",
			"value": "localhost:3001",
			"type": "string"
		}
	]
}